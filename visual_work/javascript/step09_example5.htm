<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>step09_example5.html</title>
    <style>
      canvas {
        border: 1px solid red;
      }
    </style>
  </head>
  <body>
    <h1>canvas 요소 활용해 보기</h1>

    <canvas id="myCanvas" width="800" height="500"></canvas>

    <script>
      //canvas 요소의 참조값
      let canvas = document.querySelector("#myCanvas");
      //canvas에 그림을 그릴 도구(context) 객체 얻어내기
      let context = canvas.getContext("2d");

      //canvas에 그릴 이미지 로딩하기
      let snipeImg = new Image(); // <img> 이 요소를 동적으로 만들어내는 것!
      snipeImg.src = "images/snipe.png";

      let holeImg = new Image();
      holeImg.src = "images/hole.png";

      // 배경 이미지
      const backImg = new Image();
      backImg.src = "images/background.jpg";

      //snipe의 좌표
      let snipeX = 0,
        snipeY = 0;
      // 총알 구멍의 임시 좌표
      //   let holeX = 400,
      //     holeY = 250;

      // ---> 총알 구멍 객체(object)를 저장할 배열
      const holes = []; // 페이지 로딩 시점에는 총알 자국이 없기 떄문에 비어 있어야 함.
      //이후 반복문 돌면서 총알자국 그려내기

      setInterval(() => {
        //여기 함수 내부는 1/100초 마다 한번씩 실행된다.
        // context.clearRect(0, 0, 800, 500);

        // 배경 이미지를 canvas 크기에 맞게 그린다
        context.drawImage(backImg, 0, 0, 800, 500);

        //총알 구멍 이미지를 반복문 돌면서 모두 그린다(총을 계속 쏘면 총알 자국이 하나가 아니니까)
        for (let i = 0; i < holes.length; i++) {
          //i번째 총알 구멍 이미지 정보를 담고 있는 객체를 불러와서
          let tmp = holes[i];
          //거기에 담긴 x, y 좌표를 이용해서 총알 구멍을 그린다.
          context.drawImage(holeImg, tmp.x - 10, tmp.y - 10, 20, 20);
        }

        // context.drawImage(holeImg, holeX - 10, holeY - 10, 20, 20);
        //                           폭의 반, 높이의 반 빼주면 이미지가 중앙이 됨
        context.drawImage(snipeImg, snipeX - 50, snipeY - 50, 100, 100);
      }, 10); //1초에 100번 호출

      // canvas 요소의 mousemove 이벤트 처리
      //  event는 마우스무브 이벤트 객체 {}가 전달되는 것임
      canvas.addEventListener("mousemove", (event) => {
        //이벤트가 발생한 곳의 canvas 내에서의 좌표
        snipeX = event.offsetX;
        snipeY = event.offsetY;
        //지정된 사각형 영역을 지우기 clearRect(x, y, width, height);
      });
      canvas.addEventListener("mousedown", (event) => {
        //이벤트가 발생한 곳의 좌표를 object에 담는다
        const hole = { x: event.offsetX, y: event.offsetY };
        //holes 배열에 저장(누적) 시킨다.
        holes.push(hole);

        /* 이 부분은 그냥 참고 */
        // holeX = event.offsetX;
        // holeY = event.offsetY;
        //총알을 쏘고 나면 왜 총알이 계속 그 자리에 있을까 1초에 백번씩 다시 그리고 있기 떄문에.
        // 총알 구멍의 위치를 복원시키기 위해선 내가 총쏜 위치 x,y가 다 있어야함.
        // 마우스 다운이 일어날때마다 x,y묶음이 계속 추가가 되어야함. --> 오브젝트에 담아버리잣..
        // 총알 구멍 하나당 오브젝트1개 --> 여러개의 오브젝트를 (여러 총알 구멍들을) 배열에 담아버리잣...

        // 총알 하나의 x,y 좌표는 object에 저장하면 좋을 듯...
        // {x:100, y:20}....
        // 총알 하나의 정보를 담고있는 object가 여러개면 array에 저장하면 좋을듯..
        // [{}, {}, {}, {}, ...]
      });
    </script>
  </body>
</html>
